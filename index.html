<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatial Filtering Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
            padding: 2rem;
            color: #334e68;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        h1 {
            font-family: 'Poppins', sans-serif;
            color: #1a365d;
            font-weight: 700;
            margin: 0;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.05);
        }

        .description {
            font-size: 1rem;
            max-width: 600px;
            margin-top: 0.5rem;
            color: #4a5568;
            line-height: 1.5;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 2.5rem;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 1200px;
        }

        .grid-container {
            text-align: center;
            background: #fff;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #2d3748;
            font-weight: 600;
        }
        
        #current-filter-note {
            font-size: 1.2rem;
            font-weight: 600;
            color: #64748b;
            margin-top: -1rem;
            margin-bottom: 2rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(7, 3rem);
            grid-template-rows: repeat(7, 3rem);
            border: 3px solid #64748b;
            border-radius: 12px;
            overflow: hidden;
            background-color: #e2e8f0;
        }

        .cell {
            width: 3rem;
            height: 3rem;
            border: 1px solid #c8d3dd;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1rem;
            font-weight: 600;
            box-sizing: border-box;
            transition: background-color 0.3s ease, transform 0.2s ease, color 0.3s ease;
        }

        .input-cell {
            text-align: center;
            background: #fff;
            font-size: 1.1rem;
            font-weight: 600;
            color: #334e68;
            cursor: pointer;
            border-radius: 0;
            padding: 0;
            transition: background-color 0.3s ease;
        }

        .input-cell:hover:not([disabled]), .input-cell:focus:not([disabled]) {
            background-color: #f7fafc;
            border: 1px solid #93c5fd;
            outline: none;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        .input-cell:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
            color: #a0aec0;
        }

        .output-cell {
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .output-cell:hover {
            background-color: #dbeaff;
        }

        .output-cell.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
        }

        .input-cell.highlight {
            background-color: #1e90ff;
            color: white;
            box-shadow: 0 0 10px rgba(30, 144, 255, 0.8);
            position: relative;
            z-index: 10;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        #calculation-box {
            margin-top: 2rem;
            padding: 1.5rem;
            border: 2px solid #64748b;
            background-color: #e2e8f0;
            border-radius: 12px;
            min-height: 5rem;
            text-align: center;
            width: 90%;
            max-width: 600px;
            font-size: 1rem;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.5s ease-in-out;
        }
        
        .button-group, .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .controls label {
            font-weight: 600;
            color: #4a5568;
        }

        .controls select, .controls input[type="number"] {
            padding: 0.75rem;
            border: 1px solid #c8d3dd;
            border-radius: 8px;
            background-color: #fff;
            color: #334e68;
            font-size: 1rem;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .controls select:focus, .controls input[type="number"]:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            outline: none;
        }

        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4a5568;
            color: white;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            background-color: #2d3748;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }
        
        .formula-box {
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
            margin-top: 0.5rem;
            background-color: #f7fafc;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }
            .grid {
                grid-template-columns: repeat(7, 2.5rem);
                grid-template-rows: repeat(7, 2.5rem);
            }
            .cell {
                width: 2.5rem;
                height: 2.5rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Simulator Filter Spasial</h1>
        <p class="description">
            Eksplorasi bagaimana filter spasial bekerja pada citra digital. Ubah nilai input, pilih filter, dan klik sel output untuk melihat perhitungannya. Grid akan "membungkus" di tepi, meniru efek tiling.
        </p>
    </div>
    
    <h2 id="current-filter-note">Filter Saat Ini: Averaging</h2>
    <div class="controls">
        <label for="filter-select">Pilih Filter:</label>
        <select id="filter-select" onchange="changeFilter()">
            <option value="mean">Averaging (Low-pass)</option>
            <option value="median">Median</option>
            <option value="highpass">High-pass</option>
            <option value="highboost">High-boost</option>
            <option value="prewitt">Prewitt</option>
            <option value="sobel">Sobel</option>
        </select>
        <label for="filter-size">Ukuran Filter (N x N, ganjil):</label>
        <input type="number" id="filter-size" value="3" min="3" step="2" onchange="changeFilterSize()">
        <div id="highboost-controls" style="display:none;">
            <label for="highboost-factor">Faktor Penguat ($A$):</label>
            <input type="number" id="highboost-factor" value="1.5" step="0.1">
        </div>
    </div>
    <div class="container">
        <!-- Input Grid -->
        <div class="grid-container">
            <h2>Grid Input 7x7</h2>
            <div id="input-grid" class="grid"></div>
        </div>
        
        <!-- Output Grid -->
        <div class="grid-container">
            <h2>Grid Output 7x7</h2>
            <div id="output-grid" class="grid"></div>
        </div>
    </div>
    
    <!-- Calculation Display -->
    <div id="calculation-box">
        Klik pada piksel di Grid Output untuk melihat perhitungan dan jendela yang sesuai.
    </div>
    
    <!-- Button Group -->
    <div class="button-group">
        <button onclick="resetGrids()">
            <i class="fas fa-sync-alt"></i> Reset Grid
        </button>
        <button onclick="generateRandomGrid()">
            <i class="fas fa-random"></i> Acak Ulang Input
        </button>
        <button id="edit-toggle-btn" onclick="toggleEditMode()">
            <i class="fas fa-edit"></i> Edit
        </button>
    </div>

    <script>
        const inputGrid = document.getElementById('input-grid');
        const outputGrid = document.getElementById('output-grid');
        const calculationBox = document.getElementById('calculation-box');
        const editToggleBtn = document.getElementById('edit-toggle-btn');
        const filterSelect = document.getElementById('filter-select');
        const currentFilterNote = document.getElementById('current-filter-note');
        const highboostControls = document.getElementById('highboost-controls');
        const highboostFactorInput = document.getElementById('highboost-factor');
        const filterSizeInput = document.getElementById('filter-size');
        
        let outputValues = [];
        let isEditing = false;
        let originalGridValues = [];
        const GRID_SIZE = 7;

        // Define filter kernels
        const kernels = {
            'lowpass': [
                [1/9, 1/9, 1/9],
                [1/9, 1/9, 1/9],
                [1/9, 1/9, 1/9]
            ],
            'highpass': [
                [0, -1, 0],
                [-1, 4, -1],
                [0, -1, 0]
            ],
            'prewitt-x': [
                [-1, 0, 1],
                [-1, 0, 1],
                [-1, 0, 1]
            ],
            'prewitt-y': [
                [-1, -1, -1],
                [0, 0, 0],
                [1, 1, 1]
            ],
            'sobel-x': [
                [-1, 0, 1],
                [-2, 0, 2],
                [-1, 0, 1]
            ],
            'sobel-y': [
                [-1, -2, -1],
                [0, 0, 0],
                [1, 2, 1]
            ]
        };

        // Helper function to create the grid elements
        function createGrid(gridElement, isOutput = false) {
            gridElement.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement(isOutput ? 'div' : 'input');
                cell.classList.add('cell');
                if (isOutput) {
                    cell.classList.add('output-cell');
                    // Add a click event listener to show the calculation
                    cell.addEventListener('click', () => showCalculation(Math.floor(i / GRID_SIZE), i % GRID_SIZE));
                } else {
                    cell.classList.add('input-cell');
                    cell.type = 'number';
                    cell.min = 1;
                    cell.max = 3;
                    cell.step = 1;
                    cell.addEventListener('input', updateOutput);
                    cell.disabled = true;
                }
                gridElement.appendChild(cell);
            }
        }

        // Fills the input grid with random values from 1 to 3
        function generateRandomGrid() {
            const cells = inputGrid.children;
            originalGridValues = [];
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const value = Math.floor(Math.random() * 3) + 1;
                cells[i].value = value;
                originalGridValues.push(value);
            }
            updateOutput(); // Recalculate and reset the output grid
        }

        // Updates the output grid whenever an input value changes or filter is toggled
        function updateOutput() {
            outputValues = [];
            const inputCells = inputGrid.children;
            const filterType = filterSelect.value;
            const filterSize = parseInt(filterSizeInput.value, 10);
            const halfSize = Math.floor(filterSize / 2);

            // Hide calculation box and remove active/highlighted cells
            calculationBox.innerHTML = 'Klik pada piksel di Grid Output untuk melihat perhitungan dan jendela yang sesuai.';
            document.querySelectorAll('.output-cell').forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('active');
            });
            document.querySelectorAll('.input-cell.highlight').forEach(cell => {
                cell.classList.remove('highlight');
            });
            
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;
                
                let windowValues = [];
                let result = 0;
                let calculationString = '';

                // Collect values in the sliding window with tiling effect
                for (let r = row - halfSize; r <= row + halfSize; r++) {
                    for (let c = col - halfSize; c <= col + halfSize; c++) {
                        const wrappedRow = (r + GRID_SIZE) % GRID_SIZE;
                        const wrappedCol = (c + GRID_SIZE) % GRID_SIZE;
                        const index = wrappedRow * GRID_SIZE + wrappedCol;
                        const inputValue = parseFloat(inputCells[index].value);
                        if (!isNaN(inputValue)) {
                            windowValues.push(inputValue);
                        }
                    }
                }

                // Apply the selected filter
                if (filterType === 'mean') {
                    const sum = windowValues.reduce((a, b) => a + b, 0);
                    result = windowValues.length > 0 ? (sum / windowValues.length) : 0;
                    calculationString = `(${windowValues.join(' + ')}) / ${windowValues.length} = ${result.toFixed(2)}`;
                } else if (filterType === 'median') {
                    windowValues.sort((a, b) => a - b);
                    const middleIndex = Math.floor(windowValues.length / 2);
                    result = windowValues[middleIndex];
                    calculationString = `Median dari [${windowValues.join(', ')}] adalah ${result}`;
                } else if (filterType === 'highpass' || filterType === 'lowpass' || filterType === 'prewitt' || filterType === 'sobel' || filterType === 'highboost') {
                    let Gx = 0;
                    let Gy = 0;
                    let kernelX, kernelY;
                    
                    if (filterType === 'prewitt') {
                        kernelX = kernels['prewitt-x'];
                        kernelY = kernels['prewitt-y'];
                    } else if (filterType === 'sobel') {
                        kernelX = kernels['sobel-x'];
                        kernelY = kernels['sobel-y'];
                    }
                    
                    if (filterType === 'highpass') {
                        kernelX = kernels['highpass'];
                    } else if (filterType === 'lowpass') {
                        kernelX = kernels['lowpass'];
                    }
                    
                    let convolutionResult = 0;
                    
                    for (let r = 0; r < filterSize; r++) {
                        for (let c = 0; c < filterSize; c++) {
                            const inputRow = row - halfSize + r;
                            const inputCol = col - halfSize + c;
                            const wrappedRow = (inputRow + GRID_SIZE) % GRID_SIZE;
                            const wrappedCol = (inputCol + GRID_SIZE) % GRID_SIZE;
                            const inputValue = parseFloat(inputCells[wrappedRow * GRID_SIZE + wrappedCol].value);
                            
                            if (!isNaN(inputValue)) {
                                if (filterType === 'highpass' || filterType === 'lowpass' || filterType === 'highboost') {
                                    const weight = kernelX[r][c];
                                    convolutionResult += inputValue * weight;
                                } else {
                                    const weightX = kernelX[r][c];
                                    const weightY = kernelY[r][c];
                                    Gx += inputValue * weightX;
                                    Gy += inputValue * weightY;
                                }
                            }
                        }
                    }

                    if (filterType === 'highpass' || filterType === 'lowpass') {
                        result = convolutionResult;
                        calculationString = `Formula: Sum(${windowValues.join(' $\\times$ Kernel, ')}) <br> Hasil: ${result.toFixed(2)}`;
                    } else if (filterType === 'highboost') {
                        const highpassValue = convolutionResult;
                        const originalValue = parseFloat(inputCells[i].value);
                        const A = parseFloat(highboostFactorInput.value);
                        result = originalValue + (A - 1) * highpassValue;
                        calculationString = `Original: ${originalValue}<br>High-pass output: ${highpassValue.toFixed(2)}<br>Formula: $Original + (A-1) \\times High-pass$<br> ${originalValue} + (${A}-1) \\times ${highpassValue.toFixed(2)} = ${result.toFixed(2)}`;
                    } else if (filterType === 'prewitt' || filterType === 'sobel') {
                        result = Math.sqrt(Math.pow(Gx, 2) + Math.pow(Gy, 2));
                        calculationString = `Gx: ${Gx.toFixed(2)}<br>Gy: ${Gy.toFixed(2)}<br>Magnitude: $\\sqrt{${Gx.toFixed(2)}^2 + ${Gy.toFixed(2)}^2} = ${result.toFixed(2)}`;
                    }
                }
                outputValues.push(result);
                outputGrid.children[i].setAttribute('data-calculation', calculationString);
            }
        }

        // Function to show the calculation and highlight the window
        function showCalculation(row, col) {
            // Remove any previous highlights
            document.querySelectorAll('.input-cell.highlight').forEach(cell => {
                cell.classList.remove('highlight');
            });
            document.querySelectorAll('.output-cell.active').forEach(cell => {
                cell.classList.remove('active');
            });

            const filterSize = parseInt(filterSizeInput.value, 10);
            const halfSize = Math.floor(filterSize / 2);
            
            // Highlight the new sliding window with tiling effect
            for (let r = row - halfSize; r <= row + halfSize; r++) {
                for (let c = col - halfSize; c <= col + halfSize; c++) {
                    const wrappedRow = (r + GRID_SIZE) % GRID_SIZE;
                    const wrappedCol = (c + GRID_SIZE) % GRID_SIZE;
                    const index = wrappedRow * GRID_SIZE + wrappedCol;
                    inputGrid.children[index].classList.add('highlight');
                }
            }
            
            // Highlight the currently selected output cell and display its value
            const outputCell = outputGrid.children[row * GRID_SIZE + col];
            outputCell.textContent = parseFloat(outputValues[row * GRID_SIZE + col]).toFixed(2);
            outputCell.classList.add('active');

            // Display the value and detailed calculation
            const calculationText = outputCell.getAttribute('data-calculation');
            calculationBox.innerHTML = `Perhitungan untuk (${row}, ${col}): <div class="formula-box">${calculationText}</div>`;
        }

        // Function to toggle edit mode for the input grid
        function toggleEditMode() {
            isEditing = !isEditing;
            const cells = inputGrid.children;
            for (const cell of cells) {
                cell.disabled = !isEditing;
            }
            editToggleBtn.innerHTML = isEditing ? '<i class="fas fa-check"></i> Selesai' : '<i class="fas fa-edit"></i> Edit';
            if (!isEditing) {
                updateOutput();
            }
        }

        function changeFilter() {
            const selectedFilter = filterSelect.value;
            highboostControls.style.display = selectedFilter === 'highboost' ? 'flex' : 'none';
            
            const filterNames = {
                'mean': 'Averaging (Low-pass)',
                'median': 'Median',
                'highpass': 'High-pass',
                'highboost': 'High-boost',
                'prewitt': 'Prewitt',
                'sobel': 'Sobel'
            };
            currentFilterNote.textContent = `Filter Saat Ini: ${filterNames[selectedFilter]}`;
            
            updateOutput();
        }

        function changeFilterSize() {
            let size = parseInt(filterSizeInput.value, 10);
            if (isNaN(size) || size < 3 || size % 2 === 0) {
                filterSizeInput.value = 3;
            }
            updateOutput();
        }

        // Resets the entire simulation
        function resetGrids() {
            createGrid(inputGrid);
            createGrid(outputGrid, true);
            generateRandomGrid();
            isEditing = true;
            toggleEditMode();
            filterSelect.value = 'mean';
            highboostControls.style.display = 'none';
            filterSizeInput.value = 3;
            currentFilterNote.textContent = 'Filter Saat Ini: Averaging (Low-pass)';
        }

        // Start the simulation when the page loads
        document.addEventListener('DOMContentLoaded', resetGrids);
    </script>
</body>
</html>
